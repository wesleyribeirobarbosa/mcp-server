/**
 * App.js - L√≥gica principal da Smart Cities Dashboard
 * Coordena toda a funcionalidade da aplica√ß√£o web
 */

class SmartCitiesApp {
    constructor() {
        this.isLoading = false;
        this.currentTheme = 'light';
        this.initializeApp();
    }

    /**
     * Inicializa a aplica√ß√£o
     */
    async initializeApp() {
        this.setupEventListeners();
        this.setupChartManager();
        this.loadTheme();
        await this.testBackendConnection();
        
        console.log('üèôÔ∏è Smart Cities Dashboard iniciado');
    }

    /**
     * Configura todos os event listeners
     */
    setupEventListeners() {
        // Formul√°rio de prompt
        const promptForm = document.getElementById('promptForm');
        const promptInput = document.getElementById('promptInput');
        
        if (promptForm) {
            promptForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const prompt = promptInput.value.trim();
                if (prompt) {
                    this.processPrompt(prompt);
                }
            });
        }

        // Bot√µes de consulta r√°pida
        const quickButtons = document.querySelectorAll('.quick-btn');
        quickButtons.forEach(button => {
            button.addEventListener('click', () => {
                const prompt = button.getAttribute('data-prompt');
                if (prompt) {
                    promptInput.value = prompt;
                    this.processPrompt(prompt);
                }
            });
        });

        // Toggle de tema
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                this.toggleTheme();
            });
        }

        // Bot√£o de teste de conectividade
        const testConnection = document.getElementById('testConnection');
        if (testConnection) {
            testConnection.addEventListener('click', () => {
                this.testConnectivity();
            });
        }

        // Fechar erro
        const errorDismiss = document.getElementById('errorDismiss');
        if (errorDismiss) {
            errorDismiss.addEventListener('click', () => {
                this.hideError();
            });
        }

        // Redimensionamento da janela
        window.addEventListener('resize', () => {
            if (window.chartManager) {
                window.chartManager.resizeCharts();
            }
        });

        // Teclas de atalho
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                // Ctrl+Enter para submeter prompt
                const prompt = promptInput.value.trim();
                if (prompt) {
                    this.processPrompt(prompt);
                }
            }
        });

        // Device Report Form
        const deviceReportForm = document.getElementById('deviceReportForm');
        if (deviceReportForm) {
            deviceReportForm.addEventListener('submit', (e) => {
                e.preventDefault();
                this.processDeviceReport();
            });
        }

        // Device Report Controls
        const copyReportBtn = document.getElementById('copyReportBtn');
        const downloadReportBtn = document.getElementById('downloadReportBtn');
        const closeReportBtn = document.getElementById('closeReportBtn');

        if (copyReportBtn) {
            copyReportBtn.addEventListener('click', () => {
                this.copyReportToClipboard();
            });
        }

        if (downloadReportBtn) {
            downloadReportBtn.addEventListener('click', () => {
                this.downloadReport();
            });
        }

        if (closeReportBtn) {
            closeReportBtn.addEventListener('click', () => {
                this.closeDeviceReport();
            });
        }
    }

    /**
     * Configura o gerenciador de gr√°ficos
     */
    setupChartManager() {
        if (window.chartManager) {
            const chartsContainer = document.getElementById('chartsContainer');
            window.chartManager.setContainer(chartsContainer);
        }
    }

    /**
     * Processa um prompt do usu√°rio
     */
    async processPrompt(prompt) {
        if (this.isLoading) return;

        // Valida√ß√£o de entrada
        if (!prompt || prompt.trim().length === 0) {
            this.showError('Por favor, digite uma consulta');
            return;
        }

        if (prompt.length > 1000) {
            this.showError('Consulta muito longa (m√°ximo 1000 caracteres)');
            return;
        }

        this.setLoading(true);
        this.hideError();
        this.clearResults();

        try {
            console.log('üîÑ Processando prompt:', prompt);
            
            // Verificar conectividade do backend
            await this.checkBackendHealth();
            
            // Processa prompt via backend
            const result = await window.mcpClient.processPrompt(prompt);
            
            if (result.success) {
                // Validar se h√° dados para exibir
                if (!result.data && !result.processedData) {
                    this.showError('Nenhum dado foi retornado para a consulta');
                    return;
                }
                
                this.displayResults(result);
                this.showResults();
                console.log('‚úÖ Prompt processado com sucesso');
            } else {
                this.handleApiError(result);
            }
        } catch (error) {
            console.error('‚ùå Erro inesperado:', error);
            this.handleUnexpectedError(error);
        } finally {
            this.setLoading(false);
        }
    }

    /**
     * Verifica sa√∫de do backend
     */
    async checkBackendHealth() {
        try {
            const response = await fetch('http://localhost:3001/api/health');
            if (!response.ok) {
                throw new Error('Backend indispon√≠vel');
            }
        } catch (error) {
            throw new Error('N√£o foi poss√≠vel conectar ao servidor. Verifique se o backend est√° rodando.');
        }
    }

    /**
     * Trata erros da API de forma espec√≠fica
     */
    handleApiError(result) {
        const errorType = result.errorType || 'unknown';
        let message = result.message || 'Erro desconhecido';
        
        switch (errorType) {
            case 'tool_not_found':
                message = 'üîß Ferramenta n√£o encontrada para esta consulta. Tente reformular sua pergunta.';
                break;
            case 'timeout':
                message = '‚è±Ô∏è Timeout na consulta. Tente novamente em alguns segundos.';
                break;
            case 'service_unavailable':
                message = 'üîå Servi√ßo temporariamente indispon√≠vel. Verifique se o MongoDB est√° rodando.';
                break;
            case 'validation_error':
                message = 'üìù Erro de valida√ß√£o: ' + message;
                break;
            default:
                message = '‚ùå Erro ao processar consulta: ' + message;
        }
        
        this.showError(message);
        console.error('‚ùå Erro da API:', result);
    }

    /**
     * Trata erros inesperados
     */
    handleUnexpectedError(error) {
        let message = 'Erro inesperado ao processar consulta';
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            message = 'üîå N√£o foi poss√≠vel conectar ao servidor. Verifique se o backend est√° rodando.';
        } else if (error.name === 'SyntaxError') {
            message = 'üìÑ Erro ao processar resposta do servidor.';
        } else if (error.message.includes('timeout')) {
            message = '‚è±Ô∏è Timeout na conex√£o. Tente novamente.';
        } else if (error.message) {
            message = '‚ùå ' + error.message;
        }
        
        this.showError(message);
    }

    /**
     * Exibe os resultados na interface
     */
    displayResults(responseData) {
        console.log('üìä Exibindo resultados:', responseData);
        
        // Limpa resultados anteriores
        this.clearResults();

        // Verifica estrutura de dados - pode estar em responseData.processedData ou responseData.data.processedData
        const processedData = responseData.processedData || responseData.data?.processedData;
        
        // Verifica se h√° dados processados v√°lidos
        const hasProcessedCharts = processedData && 
                                 processedData.charts && 
                                 processedData.charts.length > 0;
        
        const hasProcessedCards = processedData && 
                                processedData.cards && 
                                processedData.cards.length > 0;

        console.log('üîç Debug processedData:', {
            hasProcessedData: !!processedData,
            hasProcessedCharts,
            hasProcessedCards,
            chartsCount: processedData?.charts?.length || 0,
            cardsCount: processedData?.cards?.length || 0,
            dataStructure: {
                hasDirectProcessedData: !!responseData.processedData,
                hasNestedProcessedData: !!responseData.data?.processedData
            }
        });

        // PRIORIDADE 1: Usa dados processados do backend se dispon√≠veis
        if (hasProcessedCharts || hasProcessedCards) {
            console.log('‚úÖ Usando dados processados do backend (PRIORIDADE 1)');
            
            // Exibe cards de m√©tricas
            if (hasProcessedCards) {
                console.log('üìã Exibindo cards processados:', processedData.cards.length);
                this.displayMetricCards(processedData.cards);
            }
            
            // Exibe gr√°ficos
            if (hasProcessedCharts) {
                console.log('üìä Exibindo gr√°ficos processados:', processedData.charts.length);
                this.displayProcessedCharts(processedData.charts);
            }
            
            // Exibe dados brutos mesmo quando h√° processedData
            this.displayRawData(responseData);
            return;
        }

        console.log('‚ö†Ô∏è Dados processados n√£o encontrados, usando fallbacks');
        
        // PRIORIDADE 2: Fallbacks para dados n√£o processados
        // Exibe m√©tricas em cards (formato antigo)
        if (responseData.metrics) {
            console.log('üìã Usando m√©tricas formato antigo');
            this.displayMetrics(responseData.metrics);
        }

        // Exibe gr√°ficos (formato antigo)
        if (responseData.charts && responseData.charts.length > 0) {
            console.log('üìä Usando gr√°ficos formato antigo');
            this.displayCharts(responseData.charts);
        } else if (responseData.data) {
            console.log('üîß Tentando gerar gr√°ficos a partir dos dados brutos');
            // Tenta gerar gr√°ficos automaticamente a partir dos dados brutos
            this.generateChartsFromData(responseData);
        }

        // Exibe dados brutos
        this.displayRawData(responseData);
    }

    /**
     * Exibe cards de m√©tricas estruturados
     */
    displayMetricCards(cards) {
        const metricsContainer = document.getElementById('metricsCards');
        if (!metricsContainer) return;

        cards.forEach(cardData => {
            const card = this.createStructuredMetricCard(cardData);
            metricsContainer.appendChild(card);
        });
    }

    /**
     * Exibe gr√°ficos processados pelo backend
     */
    displayProcessedCharts(charts) {
        const chartsContainer = document.getElementById('chartsContainer');
        if (!chartsContainer) return;

        charts.forEach((chartConfig, index) => {
            // Cria container para o gr√°fico
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                margin-bottom: 24px;
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                border: 1px solid #E5E7EB;
                min-height: 400px;
                position: relative;
            `;

            // Cria canvas para o gr√°fico
            const canvas = document.createElement('canvas');
            canvas.id = `processedChart${index}`;
            canvas.style.cssText = `
                max-height: 350px;
                width: 100% !important;
                height: 350px !important;
            `;
            
            chartContainer.appendChild(canvas);
            chartsContainer.appendChild(chartContainer);

            // Configura√ß√£o completa do Chart.js
            const fullConfig = {
                type: chartConfig.type,
                data: chartConfig.data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartConfig.title,
                            color: '#1F2937',
                            font: {
                                size: 18,
                                weight: 'bold'
                            },
                            padding: {
                                top: 10,
                                bottom: 30
                            }
                        },
                        legend: {
                            display: true,
                            position: chartConfig.type === 'doughnut' || chartConfig.type === 'pie' ? 'right' : 'top',
                            labels: {
                                color: '#374151',
                                padding: 20,
                                usePointStyle: chartConfig.type === 'doughnut' || chartConfig.type === 'pie',
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(31, 41, 55, 0.95)',
                            titleColor: '#F9FAFB',
                            bodyColor: '#F9FAFB',
                            borderColor: '#6B7280',
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                label: (context) => {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y !== undefined ? context.parsed.y : context.parsed;
                                    
                                    // Para gr√°ficos de pizza/doughnut, mostrar percentual
                                    if (chartConfig.type === 'doughnut' || chartConfig.type === 'pie') {
                                        const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${context.label}: ${value.toLocaleString('pt-BR')} (${percentage}%)`;
                                    }
                                    
                                    return `${label}: ${value.toLocaleString('pt-BR')}`;
                                }
                            }
                        }
                    },
                    // Merge com configura√ß√µes espec√≠ficas do backend se existirem
                    ...chartConfig.options
                }
            };

            // Configura√ß√µes espec√≠ficas por tipo de gr√°fico
            if (chartConfig.type === 'bar') {
                fullConfig.options.scales = {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#6B7280',
                            font: {
                                size: 12
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: '#F3F4F6'
                        },
                        ticks: {
                            color: '#6B7280',
                            font: {
                                size: 12
                            },
                            callback: function(value) {
                                return value.toLocaleString('pt-BR');
                            }
                        }
                    }
                };
            }

            if (chartConfig.type === 'horizontalBar') {
                fullConfig.type = 'bar';
                fullConfig.options.indexAxis = 'y';
                fullConfig.options.scales = {
                    x: {
                        beginAtZero: true,
                        grid: {
                            color: '#F3F4F6'
                        },
                        ticks: {
                            color: '#6B7280',
                            font: {
                                size: 12
                            },
                            callback: function(value) {
                                return value.toLocaleString('pt-BR');
                            }
                        }
                    },
                    y: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#6B7280',
                            font: {
                                size: 11
                            }
                        }
                    }
                };
            }

            if (chartConfig.type === 'line') {
                fullConfig.options.scales = {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#6B7280',
                            font: {
                                size: 12
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: '#F3F4F6'
                        },
                        ticks: {
                            color: '#6B7280',
                            font: {
                                size: 12
                            },
                            callback: function(value) {
                                return value.toLocaleString('pt-BR');
                            }
                        }
                    }
                };
                
                fullConfig.options.elements = {
                    line: {
                        tension: 0.3
                    },
                    point: {
                        radius: 4,
                        hoverRadius: 6
                    }
                };
            }

            if (chartConfig.type === 'doughnut') {
                fullConfig.options.cutout = '60%';
                fullConfig.options.plugins.legend.position = 'right';
            }

            // Cria o gr√°fico
            try {
                window.chartManager.createChart(canvas.id, fullConfig);
                console.log(`‚úÖ Gr√°fico processado criado: ${chartConfig.title}`);
            } catch (error) {
                console.error('‚ùå Erro ao criar gr√°fico:', error);
            }
        });
    }

    /**
     * Exibe m√©tricas em cards (formato legado)
     */
    displayMetrics(metrics) {
        const metricsContainer = document.getElementById('metricsCards');
        if (!metricsContainer) return;

        // Converte m√©tricas para formato de cards
        const metricsData = window.mcpClient.formatMetricsData({ metrics });
        
        metricsData.forEach(metric => {
            const card = this.createMetricCard(metric);
            metricsContainer.appendChild(card);
        });
    }

    /**
     * Cria um card de m√©trica estruturado
     */
    createStructuredMetricCard(cardData) {
        const card = document.createElement('div');
        card.className = `metric-card ${cardData.status ? `status-${cardData.status}` : ''}`;
        
        // √çcones baseados no tipo
        const icons = {
            'lightbulb': 'üí°',
            'droplet': 'üíß',
            'flame': 'üî•',
            'zap': '‚ö°',  
            'activity': 'üìä',
            'check-circle': '‚úÖ',
            'alert-triangle': '‚ö†Ô∏è',
            'number': 'üìä',
            'text': 'üìù'
        };
        
        const icon = cardData.icon ? icons[cardData.icon] || 'üìä' : 'üìä';
        
        // Formata√ß√£o do valor
        let displayValue = cardData.value;
        if (cardData.type === 'number' && typeof cardData.value === 'number') {
            displayValue = cardData.value.toLocaleString('pt-BR');
        }
        
        // Adiciona cor se especificada
        const colorStyle = cardData.color ? `border-left: 4px solid ${cardData.color};` : '';
        const statusClass = cardData.status ? `status-${cardData.status}` : '';
        
        card.innerHTML = `
            <div class="metric-icon" ${cardData.color ? `style="color: ${cardData.color};"` : ''}>${icon}</div>
            <div class="metric-value">${displayValue}</div>
            <div class="metric-label">${cardData.title}</div>
            ${cardData.subtitle ? `<div class="metric-subtitle">${cardData.subtitle}</div>` : ''}
        `;
        
        if (colorStyle) {
            card.style.cssText += colorStyle;
        }
        
        if (statusClass) {
            card.classList.add(statusClass);
        }
        
        return card;
    }

    /**
     * Cria um card de m√©trica (formato legado)
     */
    createMetricCard(metric) {
        const card = document.createElement('div');
        card.className = 'metric-card';
        card.innerHTML = `
            <div class="metric-icon">${metric.icon}</div>
            <div class="metric-value" style="color: ${metric.color}">${metric.value}</div>
            <div class="metric-label">${metric.label}</div>
        `;
        return card;
    }

    /**
     * Exibe gr√°ficos
     */
    displayCharts(charts) {
        if (!window.chartManager) return;

        charts.forEach(chartConfig => {
            this.createChart(chartConfig);
        });
    }

    /**
     * Cria um gr√°fico baseado na configura√ß√£o
     */
    createChart(chartConfig) {
        const { type, data, options = {} } = chartConfig;

        switch (type) {
            case 'line':
                window.chartManager.createLineChart(data, options);
                break;
            case 'bar':
                window.chartManager.createBarChart(data, options);
                break;
            case 'pie':
            case 'doughnut':
                window.chartManager.createPieChart(data, options);
                break;
            case 'area':
                window.chartManager.createAreaChart(data, options);
                break;
            default:
                console.warn('‚ö†Ô∏è Tipo de gr√°fico n√£o suportado:', type);
                // Fallback para gr√°fico de linha
                window.chartManager.createLineChart(data, options);
        }
    }

    /**
     * Gera gr√°ficos automaticamente a partir dos dados
     */
    generateChartsFromData(responseData) {
        if (!window.chartManager) return;

        console.log('üîß Gerando gr√°ficos automaticamente para responseData:', responseData);
        
        // Extrai dados brutos do MCP Server
        let data = responseData.data;
        
        // Se os dados est√£o em formato MCP (data.content[0].text), fazer parse
        if (data && data.content && data.content[0] && data.content[0].text) {
            console.log('üîç Detectado formato MCP, fazendo parse do JSON');
            try {
                data = JSON.parse(data.content[0].text);
                console.log('‚úÖ Parse JSON realizado com sucesso:', data);
            } catch (error) {
                console.error('‚ùå Erro ao fazer parse dos dados MCP:', error);
                data = responseData.data;
            }
        }
        
        console.log('üîß Dados finais para processamento:', data);
        
        // Verifica se s√£o dados do MCP Server com estrutura espec√≠fica
        if (this.isMCPStructuredData(data)) {
            console.log('üìä Detectados dados estruturados do MCP Server');
            this.generateMCPStructuredCharts(data, responseData);
            return;
        }
        
        // L√≥gica original para outros tipos de dados
        if (Array.isArray(data)) {
            console.log('üìà Processando array de dados');
            // Array de dados - gr√°fico de linha temporal
            const chartData = window.chartManager.convertMCPData({ data }, 'line');
            if (chartData.labels.length > 0) {
                window.chartManager.createLineChart(chartData, {
                    title: responseData.title || 'Dados Temporais',
                    yAxisFormatter: (value) => value.toLocaleString()
                });
            }
        } else if (typeof data === 'object') {
            console.log('üìä Processando objeto de dados');
            // Objeto com m√∫ltiplas s√©ries
            const keys = Object.keys(data);
            
            if (keys.length > 0) {
                const firstKey = keys[0];
                const firstData = data[firstKey];
                
                if (Array.isArray(firstData)) {
                    console.log('üìà Detectados dados temporais em objeto');
                    // Dados temporais
                    const chartData = window.chartManager.convertMCPData({ data }, 'line');
                    if (chartData.labels.length > 0) {
                        window.chartManager.createLineChart(chartData, {
                            title: responseData.title || 'Compara√ß√£o de Dados'
                        });
                    }
                } else {
                    // Dados categ√≥ricos simples - s√≥ usar para dados realmente categ√≥ricos
                    console.log('üìä Gerando gr√°fico categ√≥rico para dados simples');
                    const chartData = {
                        labels: keys,
                        datasets: [{
                            label: 'Valores',
                            data: keys.map(key => data[key]),
                            backgroundColor: window.chartManager.getColorPalette()
                        }]
                    };
                    
                    window.chartManager.createBarChart(chartData, {
                        title: responseData.title || 'Dados Categ√≥ricos'
                    });
                }
            }
        } else {
            console.log('‚ö†Ô∏è Tipo de dados n√£o suportado:', typeof data);
        }
    }

    /**
     * Verifica se os dados t√™m estrutura t√≠pica do MCP Server
     */
    isMCPStructuredData(data) {
        console.log('üîç isMCPStructuredData - Verificando dados:', data);
        console.log('üîç Tipo dos dados:', typeof data);
        console.log('üîç √â array:', Array.isArray(data));
        
        if (!data || typeof data !== 'object') {
            console.log('‚ùå Dados inv√°lidos ou n√£o √© objeto');
            return false;
        }
        
        // Verifica padr√µes t√≠picos do MCP Server
        const hasOverview = data.overview && typeof data.overview === 'object';
        const hasTotals = data.totals && typeof data.totals === 'object';
        const hasAlerts = data.alerts && typeof data.alerts === 'object';
        const hasTimestamp = typeof data.timestamp === 'number';
        
        console.log('üîç Estrutura detectada:', {
            hasOverview,
            hasTotals,
            hasAlerts,
            hasTimestamp,
            keys: Object.keys(data)
        });
        
        // Dashboard da cidade
        if (hasOverview && hasTotals) {
            console.log('‚úÖ Detectado: Dashboard da cidade');
            return true;
        }
        
        // Dados de telemetria (array com deviceId, timestamp, etc.)
        if (Array.isArray(data) && data.length > 0 && data[0].deviceId && data[0].timestamp) {
            console.log('‚úÖ Detectado: Telemetria temporal');
            return true;
        }
        
        // Dados de an√°lise (com startTime, endTime, etc.)
        if (data.analysis || data.statistics || data.report) {
            console.log('‚úÖ Detectado: Dados de an√°lise');
            return true;
        }
        
        console.log('‚ùå Estrutura n√£o reconhecida');
        return false;
    }

    /**
     * Gera gr√°ficos espec√≠ficos para dados estruturados do MCP Server
     */
    generateMCPStructuredCharts(data, responseData) {
        console.log('üéØ Gerando gr√°ficos espec√≠ficos do MCP Server');
        console.log('üéØ Dados recebidos:', data);
        console.log('üéØ ResponseData completo:', responseData);
        
        // Dashboard da cidade
        if (data.overview && data.totals) {
            console.log('üèôÔ∏è Processando dashboard da cidade');
            this.generateCityDashboardCharts(data);
            return;
        }
        
        // Dados de telemetria temporal
        if (Array.isArray(data) && data.length > 0 && data[0].timestamp) {
            console.log('üìà Processando telemetria temporal');
            this.generateTelemetryCharts(data, responseData);
            return;
        }
        
        // Dados de an√°lise/relat√≥rio
        if (data.analysis || data.statistics || data.report) {
            console.log('üìä Processando dados de an√°lise');
            this.generateAnalysisCharts(data, responseData);
            return;
        }
        
        // Fallback para dados estruturados n√£o reconhecidos
        console.log('‚ö†Ô∏è Dados estruturados n√£o reconhecidos, usando fallback categ√≥rico');
        console.log('‚ö†Ô∏è Estrutura dos dados:', {
            keys: Object.keys(data),
            hasOverview: !!data.overview,
            hasTotals: !!data.totals,
            overviewType: typeof data.overview,
            totalsType: typeof data.totals
        });
        this.generateCategoricalFallback(data, responseData);
    }

    /**
     * Gera gr√°ficos para dashboard da cidade
     */
    generateCityDashboardCharts(data) {
        console.log('üèôÔ∏è Gerando gr√°ficos do dashboard da cidade');
        
        // Gr√°fico de consumo total
        if (data.totals) {
            const consumptionData = {
                labels: ['Energia (kWh)', '√Ågua (L)', 'G√°s (m¬≥)'],
                datasets: [{
                    label: 'Consumo Total',
                    data: [
                        data.totals.energyConsumption || 0,
                        data.totals.waterConsumption || 0,
                        data.totals.gasConsumption || 0
                    ],
                    backgroundColor: ['#FF6B6B', '#4ECDC4', '#45B7D1']
                }]
            };
            
            window.chartManager.createBarChart(consumptionData, {
                title: 'Consumo Total por Tipo',
                yAxisFormatter: (value) => value.toLocaleString()
            });
        }
        
        // Gr√°fico de distribui√ß√£o de dispositivos
        if (data.overview) {
            const deviceData = {
                labels: ['Ilumina√ß√£o', '√Ågua', 'G√°s'],
                datasets: [{
                    label: 'Dispositivos',
                    data: [
                        data.overview.lighting?.deviceCount || 0,
                        data.overview.water?.deviceCount || 0,
                        data.overview.gas?.deviceCount || 0
                    ],
                    backgroundColor: ['#FFD93D', '#6BCF7F', '#FF8A65']
                }]
            };
            
            window.chartManager.createPieChart(deviceData, {
                title: 'Distribui√ß√£o de Dispositivos'
            });
        }
        
        // Gr√°fico de vazamentos se houver
        if (data.overview && (data.overview.water?.leakCount > 0 || data.overview.gas?.leakCount > 0)) {
            const leakData = {
                labels: ['√Ågua', 'G√°s'],
                datasets: [{
                    label: 'Vazamentos Detectados',
                    data: [
                        data.overview.water?.leakCount || 0,
                        data.overview.gas?.leakCount || 0
                    ],
                    backgroundColor: ['#FF6B6B', '#FFA500']
                }]
            };
            
            window.chartManager.createBarChart(leakData, {
                title: 'Vazamentos por Tipo'
            });
        }
    }

    /**
     * Gera gr√°ficos para dados de telemetria temporal
     */
    generateTelemetryCharts(data, responseData) {
        console.log('üìà Gerando gr√°ficos de telemetria temporal');
        
        // Agrupa dados por timestamp
        const timeData = data.reduce((acc, reading) => {
            const time = new Date(reading.timestamp * 1000).toLocaleTimeString();
            if (!acc[time]) acc[time] = [];
            acc[time].push(reading);
            return acc;
        }, {});
        
        const timestamps = Object.keys(timeData).sort();
        
        // Detecta qual tipo de dado usar (powerConsumption, pressure, flow, etc.)
        const firstReading = data[0];
        const numericFields = Object.keys(firstReading).filter(key => 
            typeof firstReading[key] === 'number' && 
            key !== 'timestamp' && 
            key !== 'state'
        );
        
        numericFields.forEach(field => {
            const chartData = {
                labels: timestamps,
                datasets: [{
                    label: this.getFieldLabel(field),
                    data: timestamps.map(time => {
                        const readings = timeData[time];
                        return readings.reduce((sum, r) => sum + (r[field] || 0), 0) / readings.length;
                    }),
                    borderColor: this.getFieldColor(field),
                    backgroundColor: this.getFieldColor(field) + '20',
                    fill: true
                }]
            };
            
            window.chartManager.createLineChart(chartData, {
                title: `${this.getFieldLabel(field)} ao Longo do Tempo`,
                yAxisFormatter: (value) => value.toFixed(2)
            });
        });
    }

    /**
     * Gera gr√°ficos para dados de an√°lise
     */
    generateAnalysisCharts(data, responseData) {
        console.log('üìä Gerando gr√°ficos de an√°lise');
        
        // Para dados de an√°lise, extrair campos num√©ricos relevantes
        const analysisData = data.analysis || data.statistics || data.report || data;
        
        Object.keys(analysisData).forEach(key => {
            const value = analysisData[key];
            
            if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                // Array de objetos - criar gr√°fico temporal ou categ√≥rico
                this.createChartFromArray(key, value);
            } else if (typeof value === 'object' && value !== null) {
                // Objeto com m√©tricas - criar gr√°fico categ√≥rico
                this.createChartFromObject(key, value);
            }
        });
    }

    /**
     * Cria gr√°fico a partir de array de objetos
     */
    createChartFromArray(title, data) {
        if (data[0].timestamp) {
            // Dados temporais
            const chartData = window.chartManager.convertMCPData({ data }, 'line');
            if (chartData.labels.length > 0) {
                window.chartManager.createLineChart(chartData, { title });
            }
        } else {
            // Dados categ√≥ricos
            const labels = data.map((item, index) => item.name || item.label || `Item ${index + 1}`);
            const values = data.map(item => item.value || item.count || 0);
            
            const chartData = {
                labels,
                datasets: [{
                    label: title,
                    data: values,
                    backgroundColor: window.chartManager.getColorPalette()
                }]
            };
            
            window.chartManager.createBarChart(chartData, { title });
        }
    }

    /**
     * Cria gr√°fico a partir de objeto com m√©tricas
     */
    createChartFromObject(title, data) {
        const keys = Object.keys(data).filter(key => typeof data[key] === 'number');
        
        if (keys.length > 0) {
            const chartData = {
                labels: keys.map(key => this.getFieldLabel(key)),
                datasets: [{
                    label: title,
                    data: keys.map(key => data[key]),
                    backgroundColor: window.chartManager.getColorPalette()
                }]
            };
            
            window.chartManager.createBarChart(chartData, { title });
        }
    }

    /**
     * Fallback categ√≥rico melhorado
     */
    generateCategoricalFallback(data, responseData) {
        console.log('üìä Usando fallback categ√≥rico melhorado');
        
        const keys = Object.keys(data).filter(key => {
            const value = data[key];
            return typeof value === 'number' || 
                   (typeof value === 'string' && !isNaN(parseFloat(value)));
        });
        
        if (keys.length > 0) {
            const chartData = {
                labels: keys.map(key => this.getFieldLabel(key)),
                datasets: [{
                    label: 'Valores',
                    data: keys.map(key => {
                        const value = data[key];
                        return typeof value === 'number' ? value : parseFloat(value) || 0;
                    }),
                    backgroundColor: window.chartManager.getColorPalette()
                }]
            };
            
            window.chartManager.createBarChart(chartData, {
                title: responseData.title || 'Dados Categ√≥ricos'
            });
        }
    }

    /**
     * Obt√©m label amig√°vel para campo
     */
    getFieldLabel(field) {
        const labels = {
            powerConsumption: 'Consumo de Energia (kWh)',
            temp: 'Temperatura (¬∞C)',
            pressure: 'Press√£o (bar)',
            flow: 'Fluxo (L/min)',
            energyConsumption: 'Consumo de Energia',
            waterConsumption: 'Consumo de √Ågua',
            gasConsumption: 'Consumo de G√°s',
            deviceCount: 'Quantidade de Dispositivos',
            leakCount: 'Vazamentos',
            uptimePercentage: 'Uptime (%)'
        };
        
        return labels[field] || field.charAt(0).toUpperCase() + field.slice(1);
    }

    /**
     * Obt√©m cor para campo
     */
    getFieldColor(field) {
        const colors = {
            powerConsumption: '#FF6B6B',
            temp: '#FFA500',
            pressure: '#4ECDC4',
            flow: '#45B7D1',
            energyConsumption: '#FF6B6B',
            waterConsumption: '#4ECDC4',
            gasConsumption: '#45B7D1'
        };
        
        return colors[field] || '#6366F1';
    }

    /**
     * Exibe dados brutos
     */
    displayRawData(data) {
        const rawDataContent = document.getElementById('rawDataContent');
        if (rawDataContent) {
            rawDataContent.textContent = JSON.stringify(data, null, 2);
        }
    }

    /**
     * Limpa todos os resultados da interface
     */
    clearResults() {
        // Limpar cards de m√©tricas
        const metricsCards = document.getElementById('metricsCards');
        if (metricsCards) {
            metricsCards.innerHTML = '';
        }

        // Limpar gr√°ficos
        const chartsContainer = document.getElementById('chartsContainer');
        if (chartsContainer) {
            chartsContainer.innerHTML = '';
        }

        // Limpar dados brutos
        const rawDataContent = document.getElementById('rawDataContent');
        if (rawDataContent) {
            rawDataContent.textContent = '';
        }

        // Esconder se√ß√µes
        this.hideResults();
        this.hideError();
        this.hideDeviceReport();
    }

    /**
     * Processa relat√≥rio de dispositivo espec√≠fico
     */
    async processDeviceReport() {
        if (this.isLoading) return;

        const deviceType = document.getElementById('deviceTypeSelect').value;
        const deviceId = document.getElementById('deviceIdInput').value.trim();
        const reportType = document.getElementById('reportTypeSelect').value;

        // Valida√ß√£o
        if (!deviceType || !deviceId || !reportType) {
            this.showError('Por favor, preencha todos os campos obrigat√≥rios.');
            return;
        }

        // Validar formato do device ID
        if (!this.validateDeviceId(deviceType, deviceId)) {
            return;
        }

        console.log('üì± Processando relat√≥rio de dispositivo:', { deviceType, deviceId, reportType });

        // Mostrar loading
        this.setDeviceReportLoading(true);
        this.hideError();
        this.hideResults();

        try {
            // Fazer requisi√ß√£o para o backend
            const response = await fetch(`${window.mcpClient.baseURL}/device-report`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    deviceType,
                    deviceId,
                    reportType
                })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Erro ao gerar relat√≥rio');
            }

            console.log('üìÑ Relat√≥rio gerado:', data);

            // Exibir relat√≥rio
            this.displayDeviceReport(data);

        } catch (error) {
            console.error('‚ùå Erro ao processar relat√≥rio:', error);
            this.handleDeviceReportError(error);
        } finally {
            this.setDeviceReportLoading(false);
        }
    }

    /**
     * Valida o formato do device ID
     */
    validateDeviceId(deviceType, deviceId) {
        const patterns = {
            'lighting': /^LIGHT-\d{6}$/,
            'water': /^WATER-\d{6}$/,
            'gas': /^GAS-\d{6}$/
        };

        const pattern = patterns[deviceType];
        if (pattern && !pattern.test(deviceId.toUpperCase())) {
            const examples = {
                'lighting': 'LIGHT-000001',
                'water': 'WATER-000001', 
                'gas': 'GAS-000001'
            };
            
            this.showError(`Formato inv√°lido do ID. Use o formato: ${examples[deviceType]}`);
            return false;
        }

        return true;
    }

    /**
     * Define estado de loading do bot√£o de relat√≥rio
     */
    setDeviceReportLoading(isLoading) {
        const button = document.getElementById('deviceReportBtn');
        const btnText = button?.querySelector('.btn-text');
        const btnLoading = button?.querySelector('.btn-loading');

        if (button && btnText && btnLoading) {
            this.isLoading = isLoading;
            button.disabled = isLoading;

            if (isLoading) {
                btnText.style.display = 'none';
                btnLoading.style.display = 'inline';
                btnLoading.classList.remove('hidden');
            } else {
                btnText.style.display = 'inline';
                btnLoading.style.display = 'none';
                btnLoading.classList.add('hidden');
            }
        }
    }

    /**
     * Exibe o relat√≥rio de dispositivo
     */
    displayDeviceReport(reportData) {
        const reportDisplay = document.getElementById('deviceReportDisplay');
        const reportTitle = document.getElementById('deviceReportTitle');
        const reportText = document.getElementById('deviceReportText');

        if (!reportDisplay || !reportTitle || !reportText) {
            console.error('Elementos de exibi√ß√£o de relat√≥rio n√£o encontrados');
            return;
        }

        // Configurar t√≠tulo
        const deviceTypeLabel = this.getDeviceTypeLabel(reportData.deviceType);
        const reportTypeLabel = this.getReportTypeLabel(reportData.reportType);
        reportTitle.textContent = `üì± ${reportTypeLabel} - ${reportData.deviceId}`;

        // Configurar conte√∫do
        reportText.textContent = reportData.report;

        // Armazenar dados para a√ß√µes posteriores
        this.currentReport = reportData;

        // Mostrar a se√ß√£o de resultados (necess√°rio porque o deviceReportDisplay est√° dentro dela)
        this.showResults();

        // Mostrar relat√≥rio
        reportDisplay.style.display = 'block';

        // Scroll suave para o relat√≥rio
        reportDisplay.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'start' 
        });

        console.log('üìÑ Relat√≥rio exibido com sucesso');
    }

    /**
     * Trata erros de relat√≥rio de dispositivo
     */
    handleDeviceReportError(error) {
        let message = 'Erro ao gerar relat√≥rio do dispositivo';

        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            message = 'üîå N√£o foi poss√≠vel conectar ao servidor. Verifique se o backend est√° rodando.';
        } else if (error.message.includes('timeout')) {
            message = '‚è±Ô∏è Timeout na gera√ß√£o do relat√≥rio. Tente novamente.';
        } else if (error.message.includes('n√£o encontrado')) {
            message = 'üîç Dispositivo n√£o encontrado. Verifique o ID informado.';
        } else if (error.message) {
            message = '‚ùå ' + error.message;
        }

        this.showError(message);
    }

    /**
     * Copia o relat√≥rio para a √°rea de transfer√™ncia
     */
    async copyReportToClipboard() {
        if (!this.currentReport) {
            this.showError('Nenhum relat√≥rio dispon√≠vel para copiar');
            return;
        }

        try {
            await navigator.clipboard.writeText(this.currentReport.report);
            
            // Feedback visual
            const copyBtn = document.getElementById('copyReportBtn');
            const originalText = copyBtn.textContent;
            copyBtn.textContent = '‚úÖ Copiado!';
            copyBtn.style.background = '#10b981';
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.style.background = '';
            }, 2000);

            console.log('üìã Relat√≥rio copiado para √°rea de transfer√™ncia');

        } catch (error) {
            console.error('Erro ao copiar:', error);
            this.showError('Erro ao copiar relat√≥rio para √°rea de transfer√™ncia');
        }
    }

    /**
     * Baixa o relat√≥rio como arquivo TXT
     */
    downloadReport() {
        if (!this.currentReport) {
            this.showError('Nenhum relat√≥rio dispon√≠vel para download');
            return;
        }

        try {
            const filename = `relatorio_${this.currentReport.deviceId}_${this.currentReport.reportType}_${new Date().toISOString().split('T')[0]}.txt`;
            
            const blob = new Blob([this.currentReport.report], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Feedback visual
            const downloadBtn = document.getElementById('downloadReportBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.textContent = '‚úÖ Baixado!';
            downloadBtn.style.background = '#10b981';
            
            setTimeout(() => {
                downloadBtn.textContent = originalText;
                downloadBtn.style.background = '';
            }, 2000);

            console.log('üíæ Relat√≥rio baixado:', filename);

        } catch (error) {
            console.error('Erro ao baixar:', error);
            this.showError('Erro ao baixar relat√≥rio');
        }
    }

    /**
     * Fecha o relat√≥rio de dispositivo
     */
    closeDeviceReport() {
        const reportDisplay = document.getElementById('deviceReportDisplay');
        if (reportDisplay) {
            reportDisplay.style.display = 'none';
        }
        
        this.currentReport = null;
        console.log('üì± Relat√≥rio de dispositivo fechado');
    }

    /**
     * Esconde o relat√≥rio de dispositivo
     */
    hideDeviceReport() {
        const reportDisplay = document.getElementById('deviceReportDisplay');
        if (reportDisplay) {
            reportDisplay.style.display = 'none';
        }
    }

    /**
     * Obter label do tipo de dispositivo
     */
    getDeviceTypeLabel(deviceType) {
        const labels = {
            'lighting': 'üîÜ Ilumina√ß√£o',
            'water': 'üíß √Ågua',
            'gas': 'üî• G√°s'
        };
        return labels[deviceType] || deviceType;
    }

    /**
     * Obter label do tipo de relat√≥rio
     */
    getReportTypeLabel(reportType) {
        const labels = {
            'full': 'üîç Relat√≥rio Completo',
            'health': 'üè• Sa√∫de do Dispositivo',
            'telemetry': 'üìä Telemetria',
            'maintenance': 'üîß Manuten√ß√£o'
        };
        return labels[reportType] || reportType;
    }

    /**
     * Mostra a se√ß√£o de resultados
     */
    showResults() {
        const resultsSection = document.getElementById('resultsSection');
        if (resultsSection) {
            resultsSection.style.display = 'block';
            // Smooth scroll para os resultados
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    /**
     * Esconde a se√ß√£o de resultados
     */
    hideResults() {
        const resultsSection = document.getElementById('resultsSection');
        if (resultsSection) {
            resultsSection.style.display = 'none';
        }
    }

    /**
     * Mostra erro
     */
    showError(message) {
        const errorSection = document.getElementById('errorSection');
        const errorMessage = document.getElementById('errorMessage');
        
        if (errorSection && errorMessage) {
            errorMessage.textContent = message;
            errorSection.style.display = 'block';
            // Smooth scroll para o erro
            errorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    /**
     * Esconde erro
     */
    hideError() {
        const errorSection = document.getElementById('errorSection');
        if (errorSection) {
            errorSection.style.display = 'none';
        }
    }

    /**
     * Define estado de loading
     */
    setLoading(loading) {
        this.isLoading = loading;
        
        const submitBtn = document.getElementById('submitBtn');
        const btnText = submitBtn?.querySelector('.btn-text');
        const btnLoading = submitBtn?.querySelector('.btn-loading');
        
        if (submitBtn) {
            submitBtn.disabled = loading;
            
            if (btnText && btnLoading) {
                if (loading) {
                    btnText.classList.add('hidden');
                    btnLoading.classList.remove('hidden');
                } else {
                    btnText.classList.remove('hidden');
                    btnLoading.classList.add('hidden');
                }
            }
        }

        // Loading state visual para toda a interface
        const promptCard = document.querySelector('.prompt-card');
        if (promptCard) {
            if (loading) {
                promptCard.classList.add('loading');
            } else {
                promptCard.classList.remove('loading');
            }
        }
    }

    /**
     * Alterna entre tema claro e escuro
     */
    toggleTheme() {
        this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
        this.applyTheme();
        this.saveTheme();
    }

    /**
     * Aplica o tema atual
     */
    applyTheme() {
        const body = document.body;
        const themeBtn = document.getElementById('themeToggle');
        
        if (this.currentTheme === 'dark') {
            body.setAttribute('data-theme', 'dark');
            if (themeBtn) themeBtn.textContent = '‚òÄÔ∏è';
        } else {
            body.removeAttribute('data-theme');
            if (themeBtn) themeBtn.textContent = 'üåô';
        }

        // Atualiza gr√°ficos para o novo tema
        if (window.chartManager) {
            setTimeout(() => {
                window.chartManager.updateTheme();
            }, 100);
        }
    }

    /**
     * Carrega tema salvo
     */
    loadTheme() {
        const savedTheme = localStorage.getItem('smartcities-theme');
        if (savedTheme && ['light', 'dark'].includes(savedTheme)) {
            this.currentTheme = savedTheme;
        }
        this.applyTheme();
    }

    /**
     * Salva tema atual
     */
    saveTheme() {
        localStorage.setItem('smartcities-theme', this.currentTheme);
    }

    /**
     * Testa conex√£o com o backend
     */
    async testBackendConnection() {
        try {
            const result = await window.mcpClient.testConnection();
            if (result.success) {
                console.log('‚úÖ Conex√£o com backend OK');
            } else {
                console.warn('‚ö†Ô∏è Erro de conex√£o:', result.message);
                this.showError('Erro de conex√£o com o servidor. Verifique se o backend est√° rodando na porta 3001.');
            }
        } catch (error) {
            console.error('‚ùå Erro ao testar conex√£o:', error);
        }
    }

    /**
     * Testa conectividade completa com backend e MCP
     */
    async testConnectivity() {
        const testBtn = document.getElementById('testConnection');
        const testIcon = testBtn?.querySelector('.test-icon');
        const testText = testBtn?.querySelector('.test-text');
        
        if (!testBtn) return;

        // Estado de loading
        testBtn.classList.add('loading');
        testBtn.classList.remove('success', 'error');
        if (testIcon) testIcon.textContent = 'üîÑ';
        if (testText) testText.textContent = 'Testando...';

        try {
            // Testar backend
            const backendResponse = await fetch('http://localhost:3001/api/health');
            if (!backendResponse.ok) {
                throw new Error('Backend indispon√≠vel');
            }

            // Testar MCP
            const mcpResponse = await fetch('http://localhost:3001/api/test-mcp');
            const mcpResult = await mcpResponse.json();

            if (mcpResult.success) {
                // Sucesso total
                testBtn.classList.remove('loading', 'error');
                testBtn.classList.add('success');
                if (testIcon) testIcon.textContent = '‚úÖ';
                if (testText) testText.textContent = `OK (${mcpResult.data.toolsCount} tools)`;
                
                console.log('‚úÖ Conectividade OK:', mcpResult.data);
                
                // Resetar ap√≥s 3 segundos
                setTimeout(() => {
                    testBtn.classList.remove('success');
                    if (testIcon) testIcon.textContent = 'üì∂';
                    if (testText) testText.textContent = 'Status';
                }, 3000);
            } else {
                throw new Error('MCP indispon√≠vel: ' + mcpResult.error);
            }

        } catch (error) {
            // Erro
            testBtn.classList.remove('loading', 'success');
            testBtn.classList.add('error');
            if (testIcon) testIcon.textContent = '‚ùå';
            if (testText) testText.textContent = 'Erro';
            
            console.error('‚ùå Erro no teste de conectividade:', error);
            
            // Resetar ap√≥s 5 segundos
            setTimeout(() => {
                testBtn.classList.remove('error');
                if (testIcon) testIcon.textContent = 'üì∂';
                if (testText) testText.textContent = 'Status';
            }, 5000);
        }
    }

    /**
     * Utilit√°rios para debug
     */
    debug() {
        return {
            app: this,
            mcpClient: window.mcpClient,
            chartManager: window.chartManager,
            currentTheme: this.currentTheme,
            isLoading: this.isLoading
        };
    }
}

// Inicializa a aplica√ß√£o quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', () => {
    window.app = new SmartCitiesApp();
    
    // Exp√µe para debug no console
    window.debug = () => window.app.debug();
    
    console.log('üöÄ Smart Cities Dashboard carregado');
    console.log('üí° Digite debug() no console para informa√ß√µes de debug');
});
